# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
# 53 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 53 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oscfg.h" 1
# 54 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 2
# 54 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2
# 71 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_cfg.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_cfg.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_cfg.h" 2


# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_gcc.h" 1
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_gcc.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_arch_compiler_gcc.h" 1
# 64 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_gcc.h" 2
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler_cfg.h" 2
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 2
# 72 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 2
# 73 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include-fixed/limits.h" 1 3 4
# 74 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 1 3 4
# 149 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 3 4

# 149 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 216 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 328 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 3 4
typedef int wchar_t;
# 426 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stddef.h" 3 4
} max_align_t;
# 75 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stdint.h" 1 3 4
# 9 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stdint.h" 3 4
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/stdint.h" 1 3 4
# 125 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/stdint.h" 3 4
typedef signed int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef signed int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 146 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 163 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 217 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 277 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 10 "/home/user/arduino-1.8.13/hardware/tools/avr/lib/gcc/avr/7.3.0/include/stdint.h" 2 3 4
# 76 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2

# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_compiler.h" 1
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_compiler.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 64 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_compiler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 65 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_compiler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 66 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_compiler.h" 2
# 78 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2


# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/interrupt.h" 1 3
# 38 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/interrupt.h" 3
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 1 3
# 99 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 3
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/sfr_defs.h" 1 3
# 126 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/sfr_defs.h" 3
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/inttypes.h" 1 3
# 77 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/sfr_defs.h" 2 3
# 100 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3
# 272 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 3
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/iom328p.h" 1 3
# 273 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3
# 715 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 3
# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/portpins.h" 1 3
# 716 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3

# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/common.h" 1 3
# 718 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3

# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/version.h" 1 3
# 720 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3






# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/fuse.h" 1 3
# 239 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 727 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3


# 1 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/lock.h" 1 3
# 730 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/io.h" 2 3
# 39 "/home/user/arduino-1.8.13/hardware/tools/avr/avr/include/avr/interrupt.h" 2 3
# 81 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 2






# 86 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h"
typedef enum {
  OSEE_FALSE = (0!=0),
  OSEE_TRUE = (0==0)
} OsEE_bool;




typedef void * OsEE_addr;
typedef uint8_t OsEE_reg;
typedef uint8_t OsEE_stack;


typedef uint16_t OsEE_uint16;


typedef uint16_t OsEE_object_id_type;


typedef uint16_t OsEE_mem_size;


typedef uint16_t OsEE_tick_type;




typedef uint16_t OsEE_event_mask;


typedef uint8_t OsEE_isr_src_id;


typedef uint8_t OsEE_core_id;


typedef void (* OsEE_void_cb) (void);
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 2
# 98 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h"
static inline OsEE_addr osEE_get_SP ( void )
{
  return (OsEE_addr)
# 100 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 3
                   (*(volatile uint16_t *)(((((uint16_t) &((*(volatile uint16_t *)((0x3D) + 0x20)))) - 0x20)) + 0x20))
# 100 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h"
                                              ;
}

static inline OsEE_core_id osEE_get_curr_core_id ( void ) {
  return (OsEE_core_id)0U;
}
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_irq.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_irq.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_avr8_irq.h" 2
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal_internal_types.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal_internal_types.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal_internal_types.h" 2

typedef struct OsEE_CTX_tag {
  OsEE_reg r29;
  OsEE_reg r28;
  OsEE_reg r17;
  OsEE_reg r16;
  OsEE_reg r15;
  OsEE_reg r14;
  OsEE_reg r13;
  OsEE_reg r12;
  OsEE_reg r11;
  OsEE_reg r10;
  OsEE_reg r9;
  OsEE_reg r8;
  OsEE_reg r7;
  OsEE_reg r6;
  OsEE_reg r5;
  OsEE_reg r4;
  OsEE_reg r3;
  OsEE_reg r2;
  struct OsEE_CTX_tag * p_ctx;
} OsEE_CTX;


typedef struct OsEE_SCB_tag {
  OsEE_CTX * p_tos;
} OsEE_SCB;

typedef struct OsEE_SDB_tag {
  OsEE_CTX * p_bos;
  OsEE_mem_size stack_size;
} const OsEE_SDB;

typedef struct OsEE_HDB_tag {
  OsEE_SDB * p_sdb;
  OsEE_SCB * p_scb;



} const OsEE_HDB;






extern void osEE_avr8_system_timer_handler(void);
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 2





typedef unsigned char AppModeType;





typedef OsEE_reg TaskType;
typedef OsEE_reg ISRType;

typedef TaskType * TaskRefType;






typedef unsigned char TaskPrio;






typedef OsEE_isr_src_id ISRSource;




typedef unsigned char TaskActivation;




typedef OsEE_core_id CoreIdType;





typedef void (* TaskFunc) ( void );






typedef enum OsEE_task_type_tag {
  OSEE_TASK_TYPE_BASIC,
  OSEE_TASK_TYPE_EXTENDED,
  OSEE_TASK_TYPE_ISR2,
  OSEE_TASK_TYPE_IDLE
} OsEE_task_type;

typedef OsEE_task_type TaskExecutionType;

typedef enum OsEE_task_status_tag {
  OSEE_TASK_SUSPENDED,
  OSEE_TASK_READY,

  OSEE_TASK_READY_STACKED,
  OSEE_TASK_WAITING,
  OSEE_TASK_RUNNING,

  OSEE_TASK_CHAINED
} OsEE_task_status;






typedef OsEE_task_status TaskStateType;
typedef TaskStateType * TaskStateRefType;





typedef OsEE_reg CounterType;





typedef OsEE_tick_type TickType;
typedef TickType * TickRefType;







typedef OsEE_reg AlarmType;



typedef struct {

  TickType maxallowedvalue;


  TickType ticksperbase;



  TickType mincycle;

} AlarmBaseType;

typedef AlarmBaseType * AlarmBaseRefType;
# 187 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h"
typedef OsEE_reg ResourceType;
# 200 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h"
typedef OsEE_event_mask EventMaskType;

typedef EventMaskType * EventMaskRefType;
# 213 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h"
typedef OsEE_object_id_type ObjectIDType;






typedef OsEE_mem_size MemSize;







typedef enum OsEE_status_type_tag {
  E_OK,
  E_OS_ACCESS,
  E_OS_CALLEVEL,
  E_OS_ID,
  E_OS_LIMIT,
  E_OS_NOFUNC,
  E_OS_RESOURCE,
  E_OS_STATE,
  E_OS_VALUE,
  E_OS_SERVICEID,
  E_OS_ILLEGAL_ADDRESS,
  E_OS_MISSINGEND,
  E_OS_DISABLEDINT,
  E_OS_STACKFAULT,
  E_OS_PARAM_POINTER,
  E_OS_PROTECTION_MEMORY,
  E_OS_PROTECTION_TIME,
  E_OS_PROTECTION_ARRIVAL,
  E_OS_PROTECTION_LOCKED,
  E_OS_PROTECTION_EXCEPTION,

  E_OS_SPINLOCK,
  E_OS_INTERFERENCE_DEADLOCK,
  E_OS_NESTING_DEADLOCK,

  E_OS_CORE,


  E_OS_SYS_INIT,

  E_OS_SYS_TASK,
  E_OS_SYS_STACK,
  E_OS_SYS_ACT
} OsEE_status_type;

typedef OsEE_status_type StatusType;







typedef union OsEE_api_param_tag {
  ObjectIDType num_param;
  OsEE_addr p_param;
} OsEE_api_param;






typedef enum OsEE_service_id_type_tag {
  OSServiceId_ActivateTask = (0),
  OSServiceId_ActivateTask_Entry = (1),
  OSServiceId_TerminateTask = (2),
  OSServiceId_TerminateTask_Entry = (3),
  OSServiceId_ChainTask = (4),
  OSServiceId_ChainTask_Entry = (5),
  OSServiceId_Schedule = (6),
  OSServiceId_Schedule_Entry = (7),
  OSServiceId_GetTaskID = (8),
  OSServiceId_GetTaskID_Entry = (9),
  OSServiceId_GetTaskState = (10),
  OSServiceId_GetTaskState_Entry = (11),
  OSServiceId_DisableAllInterrupts = (12),
  OSServiceId_DisableAllInterrupts_Entry = (13),
  OSServiceId_EnableAllInterrupts = (14),
  OSServiceId_EnableAllInterrupts_Entry = (15),
  OSServiceId_SuspendAllInterrupts = (16),
  OSServiceId_SuspendAllInterrupts_Entry = (17),
  OSServiceId_ResumeAllInterrupts = (18),
  OSServiceId_ResumeAllInterrupts_Entry = (19),
  OSServiceId_SuspendOSInterrupts = (20),
  OSServiceId_SuspendOSInterrupts_Entry = (21),
  OSServiceId_ResumeOSInterrupts = (22),
  OSServiceId_ResumeOSInterrupts_Entry = (23),

  OSServiceId_GetResource = (24),
  OSServiceId_GetResource_Entry = (25),
  OSServiceId_ReleaseResource = (26),
  OSServiceId_ReleaseResource_Entry = (27),


  OSServiceId_SetEvent = (28),
  OSServiceId_SetEvent_Entry = (29),
  OSServiceId_ClearEvent = (30),
  OSServiceId_ClearEvent_Entry = (31),
  OSServiceId_GetEvent = (32),
  OSServiceId_GetEvent_Entry = (33),
  OSServiceId_WaitEvent = (34),
  OSServiceId_WaitEvent_Entry = (35),


  OSServiceId_GetAlarmBase = (36),
  OSServiceId_GetAlarmBase_Entry = (37),
  OSServiceId_GetAlarm = (38),
  OSServiceId_GetAlarm_Entry = (39),
  OSServiceId_SetRelAlarm = (40),
  OSServiceId_SetRelAlarm_Entry = (41),
  OSServiceId_SetAbsAlarm = (42),
  OSServiceId_SetAbsAlarm_Entry = (43),
  OSServiceId_CancelAlarm = (44),
  OSServiceId_CancelAlarm_Entry = (45),


  OSServiceId_IncrementCounter = (46),
  OSServiceId_IncrementCounter_Entry = (47),
  OSServiceId_GetCounterValue = (48),
  OSServiceId_GetCounterValue_Entry = (49),
  OSServiceId_GetElapsedValue = (50),
  OSServiceId_GetElapsedValue_Entry = (51),

  OSServiceId_GetActiveApplicationMode = (52),
  OSServiceId_GetActiveApplicationMode_Entry = (53),
  OSServiceId_ShutdownOS = (54),
  OSServiceId_ShutdownOS_Entry = (55),
  OSServiceId_StartOS = (56),
  OSServiceId_StartOS_Entry = (57),


  OSId_TaskBody = (58),


  OSId_TaskBody_Entry = (59),


  OSId_ISR2Body = (60),

  OSId_ISR2Body_Entry = (61),


  OSId_Action = (62),
  OSId_Action_Entry = (63),

  OSId_Kernel = (64),
  OSId_Kernel_Entry = (65),
  OsId_Invalid = (66)
} OsEE_service_id_type;


typedef OsEE_service_id_type OSServiceIdType;
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_extension.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_extension.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_extension.h" 2
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal_internal_types.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 2


struct OsEE_TDB_tag;





typedef struct OsEE_SN_tag {
  struct OsEE_SN_tag * p_next;
  struct OsEE_TDB_tag const * p_tdb;
} OsEE_SN;

static inline OsEE_SN *
  osEE_sn_alloc
(
  OsEE_SN * * pp_fist
)
{
  OsEE_SN * p_sn_allocated;

  p_sn_allocated = (*pp_fist);
  (*pp_fist) = p_sn_allocated->p_next;
  p_sn_allocated->p_next = 
# 84 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 3 4
                           ((void *)0)
# 84 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h"
                               ;

  return p_sn_allocated;
}

static inline void
  osEE_sn_release
(
  OsEE_SN * * pp_first,
  OsEE_SN * p_to_free
)
{
  p_to_free->p_next = (*pp_first);
  (*pp_first) = p_to_free;
}

OsEE_bool
  osEE_sn_priority_insert
(
  OsEE_SN * * pp_first,
  OsEE_SN * p_sn_new,
  OsEE_bool const hnd_act
);
# 159 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h"
typedef OsEE_SN * OsEE_RQ;
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 2
# 80 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
typedef void (* OsEE_kernel_cb) (void);

typedef unsigned char OsEE_byte;





typedef unsigned char CoreMaskType;
# 99 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
typedef enum OsEE_os_context_tag{
  OSEE_KERNEL_CTX,
  OSEE_TASK_CTX,
  OSEE_TASK_ISR2_CTX,
  OSEE_ERRORHOOK_CTX,
  OSEE_PROTECTIONHOOK_CTX,
  OSEE_PRETASKHOOK_CTX,
  OSEE_POSTTASKHOOK_CTX,
  OSEE_STARTUPHOOK_CTX,
  OSEE_SHUTDOWNHOOK_CTX,
  OSEE_ALARMCALLBACK_CTX,
  OSEE_IDLE_CTX
} OsEE_os_context;

typedef enum {



  OSEE_KERNEL_STOPPED,
  OSEE_KERNEL_STARTING,
  OSEE_KERNEL_STARTED,
  OSEE_KERNEL_SHUTDOWN
} OsEE_kernel_status;



struct OsEE_MDB_tag;

typedef struct OsEE_MCB_tag {
  struct OsEE_MDB_tag const * p_next;
  TaskPrio prev_prio;

  OsEE_bool locked;




} OsEE_MCB;
# 145 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
typedef struct OsEE_MDB_tag {
  OsEE_MCB * p_mcb;
  TaskPrio mtx_prio;





} const OsEE_MDB;


typedef struct OsEE_TCB_tag {
  TaskActivation current_num_of_act;
  TaskPrio current_prio;
  TaskStateType status;

  OsEE_MDB * p_first_mtx;


  EventMaskType wait_mask;
  EventMaskType event_mask;




} OsEE_TCB;

typedef struct OsEE_TDB_tag {
  OsEE_HDB hdb;
  OsEE_TCB * p_tcb;
  TaskType tid;
  TaskExecutionType task_type;
  TaskFunc task_func;
  TaskPrio ready_prio;
  TaskPrio dispatch_prio;
  TaskActivation max_num_of_act;



} const OsEE_TDB;

typedef struct OsEE_TW_tag {
  OsEE_TDB * p_tdb;
  TaskFunc real_task_func;
} const OsEE_TW;
# 198 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
struct OsEE_TriggerDB_tag;



typedef struct OsEE_TriggerDB_tag const *
  OsEE_TriggerQ;

typedef struct OsEE_CounterCB_tag {
  OsEE_TriggerQ trigger_queue;
  TickType value;



} OsEE_CounterCB;
# 220 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
typedef struct OsEE_CounterDB_tag {
  OsEE_CounterCB * p_counter_cb;



  AlarmBaseType info;



} const OsEE_CounterDB;

typedef enum {
  OSEE_ACTION_TASK,
  OSEE_ACTION_EVENT,
  OSEE_ACTION_COUNTER,
  OSEE_ACTION_CALLBACK
} OsEE_action_type;

typedef struct OsEE_action_param {
  OsEE_kernel_cb f;
  OsEE_TDB * p_tdb;
  OsEE_CounterDB * p_counter_db;

  EventMaskType mask;

} OsEE_action_param;

typedef struct OsEE_action_tag {
  OsEE_action_param param;
  OsEE_action_type type;
} OsEE_action;
# 259 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
typedef struct OsEE_TriggerCB_tag {
  struct OsEE_TriggerDB_tag const * p_next;
  TickType when;
  OsEE_bool active;


  TickType cycle;




} OsEE_TriggerCB;

typedef struct OsEE_TriggerDB_tag {
  OsEE_TriggerCB * p_trigger_cb;
  OsEE_CounterDB * p_counter_db;



  OsEE_action action;



} const OsEE_TriggerDB;


typedef struct OsEE_autostart_trigger_info_tag {
  OsEE_TriggerDB * p_trigger_db;
  TickType increment;
  TickType cycle;
} const OsEE_autostart_trigger_info;

typedef struct OsEE_autostart_trigger_tag {
  OsEE_autostart_trigger_info (* p_trigger_ptr_array)[];
  MemSize trigger_array_size;
} const OsEE_autostart_trigger;
# 308 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
typedef OsEE_TriggerCB OsEE_AlarmCB;
typedef OsEE_TriggerDB OsEE_AlarmDB;






typedef struct OsEE_autostart_tdb_tag {
  OsEE_TDB * const (* p_tdb_ptr_array)[];
  MemSize tdb_array_size;
} const OsEE_autostart_tdb;


typedef struct OsEE_CCB_tag {
  OsEE_TDB * p_curr;




  OsEE_RQ rq;
  OsEE_SN * p_free_sn;




  OsEE_SN * p_stk_sn;
  OsEE_kernel_status os_status;
  AppModeType app_mode;

  StatusType last_error;
# 355 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
  OsEE_reg prev_s_isr_all_status;
  OsEE_reg prev_s_isr_os_status;
  OsEE_byte s_isr_all_cnt;
  OsEE_byte s_isr_os_cnt;
  OsEE_byte d_isr_all_cnt;



} OsEE_CCB;

typedef struct OsEE_CDB_tag {



  OsEE_CCB * p_ccb;

  TaskFunc p_idle_hook;

  OsEE_TDB * p_idle_task;

  OsEE_CounterDB * p_sys_counter_db;


  OsEE_autostart_tdb (* p_autostart_tdb_array)[];
  MemSize autostart_tdb_array_size;


  OsEE_autostart_trigger (* p_autostart_trigger_array)[];
  MemSize autostart_trigger_array_size;




} const OsEE_CDB;

typedef struct OsEE_KCB_tag {
# 412 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
  OsEE_reg dummy;

} OsEE_KCB;

typedef struct OsEE_KDB_tag {
  OsEE_KCB * p_kcb;






  OsEE_TDB * const (* p_tdb_ptr_array)
    [ ];




  OsEE_SN (* p_sn_array)
    [ ];
  MemSize tdb_array_size;
  MemSize sn_array_size;

  OsEE_MDB * const (* p_res_ptr_array)[];
  MemSize res_array_size;


  OsEE_CounterDB * const (* p_counter_ptr_array)[];
  MemSize counter_array_size;

  OsEE_AlarmDB * const (* p_alarm_ptr_array)[];
  MemSize alarm_array_size;





} const OsEE_KDB;
# 477 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h"
extern void
  osEE_change_context_from_task_end
(
  OsEE_TDB * p_from,
  OsEE_TDB * p_to
);

extern void
  osEE_idle_hook_wrapper
(
  void
);
# 64 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 1
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 1
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal_internal_types.h" 1
# 64 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 1
# 65 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 1
# 66 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h" 2
# 83 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h"
void
  osEE_hal_save_ctx_and_restore_ctx
(
  OsEE_TDB * p_to_tdb,
  OsEE_SCB * p_to_scb,
  OsEE_SCB * p_from_scb
);

void
  osEE_hal_restore_ctx
(
  OsEE_TDB * p_to_tdb,
  OsEE_SCB * p_to_scb
);

void
  osEE_hal_save_ctx_and_ready2stacked
(
  OsEE_TDB * p_to_tdb,
  OsEE_SCB * p_to_scb,
  OsEE_SCB * p_from_scb
);

void
  osEE_hal_ready2stacked
(
  OsEE_TDB * p_to_tdb,
  OsEE_SCB * p_to_scb
);

void __attribute__((noreturn))
  osEE_hal_terminate_ctx
(
  OsEE_SCB * p_term_scb,
  OsEE_kernel_cb kernel_cb
);
# 129 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h"
static inline void
  osEE_hal_terminate_activation
(
  OsEE_HDB * p_to_term,
  OsEE_kernel_cb kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
}

static inline void
  osEE_idle_task_start
(
  OsEE_TDB * p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
    p_idle_tdb->hdb.p_scb);
}

void
  osEE_idle_task_terminate
(
  OsEE_TDB * p_idle_tdb
);





static inline OsEE_bool
  osEE_std_cpu_startos ( void ) {

  return OSEE_TRUE;
}
# 179 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_std_change_context.h"
static inline void
  osEE_hal_signal_broadcast
(
  void
)
{

  ((void)0);
}

static inline void
  osEE_hal_signal_core
(
  CoreIdType core_id
)
{

  ((void)core_id);
}
# 65 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2


# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_atmega_timer1ctc.h" 1
# 96 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_atmega_timer1ctc.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 97 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_atmega_timer1ctc.h" 2
# 122 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_atmega_timer1ctc.h"
void OsEE_atmega_startTimer1(uint32_t microsecondsInterval);
# 68 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 2
# 98 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h"
static inline void osEE_hal_disableIRQ( void )
{
  
# 100 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 3
 __asm__ __volatile__ ("cli" ::: "memory")
# 100 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h"
      ;
}

static inline void osEE_hal_enableIRQ( void )
{
  
# 105 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 3
 __asm__ __volatile__ ("sei" ::: "memory")
# 105 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h"
      ;
}


static inline OsEE_reg osEE_hal_suspendIRQ ( void )
{
  register OsEE_reg sr = 
# 111 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 3
                        (*(volatile uint8_t *)((0x3F) + 0x20))
# 111 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h"
                            ;
  osEE_hal_disableIRQ();
  return sr;
}

static inline void osEE_hal_resumeIRQ ( OsEE_reg flags )
{
  __asm__ volatile("" : : : "memory");
  
# 119 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 3
 (*(volatile uint8_t *)((0x3F) + 0x20)) 
# 119 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h"
      = flags;
}

static inline void osEE_hal_set_ipl(TaskPrio virt_prio) {
  (void)virt_prio;
}

static inline OsEE_reg
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{

  (void)virt_prio;
  return flags;
}







static inline OsEE_reg osEE_hal_begin_nested_primitive( void )
{
  return osEE_hal_suspendIRQ();
}



static inline void osEE_hal_end_nested_primitive( OsEE_reg flag )
{
  osEE_hal_resumeIRQ(flag);
}





extern void osEE_atmega_intvect(void);


extern void osEE_avr8_system_timer_init(void);





static inline OsEE_bool osEE_cpu_startos ( void )
{

  OsEE_void_cb volatile ivt = &osEE_atmega_intvect;
  OsEE_bool const cpu_startos_ok = osEE_std_cpu_startos();

  if (cpu_startos_ok) {
    osEE_avr8_system_timer_init();
  }

  return cpu_startos_ok;
}

static inline void
  osEE_change_context_from_isr2_end
(
  OsEE_TDB * p_from,
  OsEE_TDB * p_to
)
{
  osEE_change_context_from_task_end(p_from, p_to);
}
# 55 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_osek.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_osek.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_osek.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_osek.h" 2





void
  DisableAllInterrupts
(
  void
);

void
  EnableAllInterrupts
(
  void
);

void
  SuspendAllInterrupts
(
  void
);

void
  ResumeAllInterrupts
(
  void
);

void
  SuspendOSInterrupts
(
  void
);

void
  ResumeOSInterrupts
(
  void
);

StatusType
  StartOS
(
  AppModeType Mode
);

AppModeType
  GetActiveApplicationMode
(
  void
);

StatusType
  ActivateTask
(
  TaskType TaskID
);

StatusType
  ChainTask
(
  TaskType TaskID
);

StatusType
  TerminateTask
(
  void
);

StatusType
  GetTaskID
(
  TaskRefType TaskID
);

StatusType
  GetTaskState
(
  TaskType TaskID,
  TaskStateRefType State
);

StatusType
  Schedule
(
  void
);


StatusType
  GetResource
(
  ResourceType ResID
);

StatusType
  ReleaseResource
(
  ResourceType ResID
);


StatusType
  ShutdownOS
(
  StatusType Error
);


StatusType
  SetRelAlarm
(
  AlarmType AlarmID,
  TickType increment,
  TickType cycle
);

StatusType
  SetAbsAlarm
(
  AlarmType AlarmID,
  TickType start,
  TickType cycle
);

StatusType
  GetAlarm
(
  AlarmType AlarmID,
  TickRefType Tick
);

StatusType
  GetAlarmBase
(
  AlarmType AlarmID,
  AlarmBaseRefType Info
);

StatusType
  CancelAlarm
(
  AlarmType AlarmID
);



static inline CoreIdType
  GetCoreID
(
  void
)
{
  return osEE_get_curr_core_id();
}


StatusType
  WaitEvent
(
  EventMaskType Mask
);

StatusType
  SetEvent
(
  TaskType TaskID,
  EventMaskType Mask
);

StatusType
  GetEvent
(
  TaskType TaskID,
  EventMaskRefType Event
);

StatusType
  ClearEvent
(
  EventMaskType Mask
);
# 253 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_osek.h"
extern void StartupHook(void);
# 349 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_osek.h"
ISRType
  GetISRID
(
  void
);
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_dynamic.h" 1
# 53 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_dynamic.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 54 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_dynamic.h" 2
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_oo_api_extension.h" 1
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 1
# 64 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api.h" 2
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_hal_internal.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_get_kernel_and_core.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_get_kernel_and_core.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_get_kernel_and_core.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_get_kernel_and_core.h" 2

extern OsEE_KDB KDB;
extern OsEE_CDB CDB;
extern OsEE_KCB KCB;
extern OsEE_CCB CCB;







static inline OsEE_CDB * osEE_get_curr_core ( void ) {
  return &CDB;
}

static inline OsEE_CDB * osEE_get_core ( CoreIdType core_id ) {
  return &CDB;
}

static inline OsEE_KDB * osEE_get_kernel ( void ) {
  return &KDB;
}

static inline void osEE_lock_kernel ( void ) {}

static inline OsEE_KDB * osEE_lock_and_get_kernel ( void ) {
  osEE_lock_kernel ();
  return osEE_get_kernel();
}

static inline void osEE_unlock_kernel ( void ) {}

static inline CoreIdType osEE_lock_and_get_curr_core_id ( void ) {
  return 0;
}

static inline void osEE_lock_core_id ( CoreIdType core_id ) {}

static inline void osEE_lock_core ( OsEE_CDB * const p_cdb ) {}

static inline OsEE_CDB * osEE_lock_and_get_core ( CoreIdType core_id ) {
  return osEE_get_curr_core();
}

static inline OsEE_CDB * osEE_lock_and_get_curr_core ( void ) {
  return osEE_get_curr_core();
}

static inline void osEE_unlock_core_id ( CoreIdType core_id ) {}

static inline void osEE_unlock_core ( OsEE_CDB * const p_cdb ) {}

static inline void osEE_unlock_curr_core ( void ) {}
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 1
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h"
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_cfg.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_utils.h" 1
# 58 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_compiler.h" 1
# 59 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_platform_types.h" 1
# 60 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_api_types.h" 1
# 61 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_hal_internal_types.h" 1
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_scheduler_types.h" 1
# 63 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_kernel_types.h" 1
# 64 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_scheduler.h" 2

OsEE_bool
  osEE_scheduler_rq_insert
(
  OsEE_RQ * p_rq,
  OsEE_SN * p_sn_new,
  OsEE_TDB * const p_tdb_new
);




typedef OsEE_TDB OsEE_preempt;


OsEE_preempt *
  osEE_scheduler_core_rq_preempt_stk
(
  OsEE_CDB * p_cdb,
  OsEE_RQ * p_rq
);

OsEE_SN *
  osEE_scheduler_core_pop_running
(
  OsEE_CDB * p_cdb,
  OsEE_RQ * p_rq
);



void
  osEE_scheduler_task_end
(
  void
);


void
  osEE_scheduler_task_wrapper_run
(
  OsEE_TDB * p_tdb_to
);

void
  osEE_scheduler_task_wrapper_restore
(
  OsEE_TDB * p_tdb_to
);

StatusType
  osEE_scheduler_task_activated
(
  OsEE_KDB * p_kdb,
  OsEE_CDB * p_cdb,
  OsEE_TDB * p_tdb_act,
  OsEE_bool const is_preemption_point
);

OsEE_bool
  osEE_scheduler_task_preemption_point
(
  OsEE_KDB * p_kdb,
  OsEE_CDB * p_cdb
);

OsEE_TDB *
  osEE_scheduler_task_block_current
(
  OsEE_KDB * p_kdb,
  OsEE_CDB * p_cdb,
  OsEE_SN * * p_sn_blocked
);

OsEE_bool
  osEE_scheduler_task_unblocked
(
  OsEE_KDB * p_kdb,
  OsEE_CDB * p_cdb,
  OsEE_SN * p_sn_released
);

void
  osEE_scheduler_task_set_running
(
  OsEE_KDB * p_kdb,
  OsEE_CDB * p_cdb,
  OsEE_TDB * p_tdb
);

OsEE_TDB *
  osEE_scheduler_task_terminated
(
  OsEE_KDB * p_kdb,
  OsEE_CDB * p_cdb,
  OsEE_TDB * * pp_tdb_from
);
# 62 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h" 2

void
  osEE_change_context_from_running
(
  OsEE_TDB * p_from,
  OsEE_TDB * p_to
);
# 80 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h"
static inline OsEE_bool
  osEE_cpu_startos
(
  void
);

static inline OsEE_TDB *
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
}

static inline OsEE_CDB *
  osEE_get_task_curr_core
(
  OsEE_TDB * p_tdb
)
{

  ((void)p_tdb);
  return osEE_get_curr_core();





}

static inline void
  osEE_task_end
(
  OsEE_TDB * const p_tdb
)
{
  OsEE_TCB * const p_tcb = p_tdb->p_tcb;

  p_tcb->current_prio = p_tdb->ready_prio;

  --p_tcb->current_num_of_act;

  if (p_tcb->current_num_of_act == 0U) {
    p_tcb->status = OSEE_TASK_SUSPENDED;
  } else {
    p_tcb->status = OSEE_TASK_READY;
  }
}

static inline OsEE_reg
  osEE_begin_primitive
(
  void
)
{
  return osEE_hal_begin_nested_primitive();
}

static inline void
  osEE_end_primitive
(
  OsEE_reg flags
)
{
  osEE_hal_end_nested_primitive(flags);
}

static inline void
  osEE_orti_trace_service_entry
(
  OsEE_CCB * p_ccb,
  OSServiceIdType const service_id
)
{





  (void)p_ccb;
  (void)service_id;

}

static inline void
  osEE_orti_trace_service_exit
(
  OsEE_CCB * p_ccb,
  OSServiceIdType const service_id
)
{







  (void)p_ccb;
  (void)service_id;

}

static inline StatusType
  osEE_activate_isr2
(
  TaskType isr2_id
)
{
  StatusType ret_val = E_OK;
  OsEE_KDB * const p_kdb = osEE_get_kernel();
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_TDB * const
    p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];


  ++p_act_tdb->p_tcb->current_num_of_act;

  osEE_scheduler_task_set_running(p_kdb, p_cdb, p_act_tdb);

  return ret_val;
}

static inline OsEE_bool
  osEE_is_valid_tid
(
  OsEE_KDB * p_kdb,
  TaskType tid
)
{




  return (tid < p_kdb->tdb_array_size);

}


static inline OsEE_bool
  osEE_is_valid_res_id
(
  OsEE_KDB * p_kdb,
  ResourceType res_id
)
{



  return (res_id < p_kdb->res_array_size);

}


static inline OsEE_bool
  osEE_is_active_task
(
  OsEE_TCB * p_tcb
)
{
  return (p_tcb->status > OSEE_TASK_READY);
}

static inline void
  osEE_event_reset_mask
(
  OsEE_TCB * p_tcb
)
{

  p_tcb->event_mask = 0U;



}


static inline OsEE_bool
  osEE_check_disableint
(
  OsEE_CCB * p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
    (p_ccb->d_isr_all_cnt > 0U);
}


static inline void
  osEE_call_startup_hook
(
  OsEE_CCB * p_ccb
)
{






  ((void)p_ccb);

  StartupHook();







}

static inline void
  osEE_call_pre_task_hook
(
  OsEE_CCB * p_ccb
)
{
# 311 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h"
  ((void)p_ccb);

}

static inline void
  osEE_call_post_task_hook
(
  OsEE_CCB * p_ccb
)
{
# 333 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h"
  ((void)p_ccb);

}

static inline void
  osEE_call_shutdown_hook
(
  OsEE_CCB * p_ccb,
  StatusType Error
)
{
# 356 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h"
  ((void)p_ccb);
  ((void)Error);

}

static inline void
  osEE_call_error_hook
(
  OsEE_CCB * p_ccb,
  StatusType Error
)
{
# 377 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_kernel.h"
  ((void)p_ccb);
  ((void)Error);

}

static inline void
  osEE_set_service_id
(
  OsEE_CCB * p_ccb,
  OSServiceIdType service_id
)
{



  ((void)p_ccb);
  ((void)service_id);



}

static inline void
  osEE_set_api_param1
(
  OsEE_CCB * p_ccb,
  OsEE_api_param api_param
)
{



  ((void)p_ccb);
  ((void)api_param);

}

static inline void
  osEE_set_api_param2
(
  OsEE_CCB * p_ccb,
  OsEE_api_param api_param
)
{



  ((void)p_ccb);
  ((void)api_param);

}

static inline void
  osEE_set_api_param3
(
  OsEE_CCB * p_ccb,
  OsEE_api_param api_param
)
{



  ((void)p_ccb);
  ((void)api_param);

}


void
  osEE_counter_insert_rel_trigger
(
  OsEE_CounterDB * p_counter_db,
  OsEE_TriggerDB * p_trigger_db,
  TickType delta
);

void
  osEE_counter_insert_abs_trigger
(
  OsEE_CounterDB * p_counter_cb,
  OsEE_TriggerDB * p_trigger_db,
  TickType when
);

void
  osEE_counter_cancel_trigger
(
  OsEE_CounterDB * p_counter_db,
  OsEE_TriggerDB * p_trigger_db
);

void
  osEE_counter_increment
(
  OsEE_CounterDB * p_counter_db
);


static inline TickType
  osEE_counter_eval_when
(
  OsEE_CounterDB * p_counter_db,
  TickType delta
)
{
  TickType when;
  OsEE_CounterCB * const
    p_counter_cb = p_counter_db->p_counter_cb;
  TickType const
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  TickType const
    value = p_counter_cb->value;

  if (maxallowedvalue - delta >= value) {
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
  }

  return when;
}

static inline TickType
  osEE_counter_eval_delta
(
  OsEE_CounterDB * p_counter_db,
  TickType when
)
{
  TickType delta;
  OsEE_CounterCB * const
    p_counter_cb = p_counter_db->p_counter_cb;
  TickType const
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  TickType const
    value = p_counter_cb->value;

  if (when > value) {
    delta = when - value;
  } else {
    delta = (maxallowedvalue - value) + when + 1U;
  }

  return delta;
}


StatusType
  osEE_alarm_set_rel
(
  OsEE_CounterDB * p_counter_db,
  OsEE_AlarmDB * p_alarm_db,
  TickType increment,
  TickType cycle
);

StatusType
  osEE_alarm_set_abs
(
  OsEE_CounterDB * p_counter_db,
  OsEE_AlarmDB * p_alarm_db,
  TickType start,
  TickType cycle
);

StatusType
  osEE_alarm_cancel
(
  OsEE_AlarmDB * p_alarm_db
);

StatusType
  osEE_alarm_get
(
  OsEE_AlarmDB * p_alarm_db,
  TickType * p_tick
);

static inline OsEE_bool
  osEE_is_valid_alarm_id
(
  OsEE_KDB * p_kdb,
  AlarmType alarm_id
)
{



  return (alarm_id < p_kdb->alarm_array_size);

}

static inline OsEE_TriggerDB *
  osEE_alarm_get_trigger_db
(
  OsEE_AlarmDB * p_alarm_db
)
{



  return p_alarm_db;

}

static inline OsEE_AlarmCB *
  osEE_alarm_get_cb
(
  OsEE_AlarmDB * p_alarm_db
)
{
  return (OsEE_AlarmCB * )
    (osEE_alarm_get_trigger_db(p_alarm_db)->p_trigger_cb);
}
# 56 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 2
# 1 "/home/user/lab-osek/OSEK-GroupProject/erika/inc/ee_get_kernel_and_core.h" 1
# 57 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 2





void
  DisableAllInterrupts
(
  void
)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;

  osEE_hal_disableIRQ();
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_DisableAllInterrupts);
  return;
}

void
  EnableAllInterrupts
(
  void
)
{





  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  if (p_ccb->d_isr_all_cnt > 0U) {
    p_ccb->d_isr_all_cnt = 0U;
    osEE_hal_enableIRQ();
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_EnableAllInterrupts);

  return;
}

void
  SuspendAllInterrupts
(
  void
)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendAllInterrupts);

  if (p_ccb->s_isr_all_cnt == 0U) {
    OsEE_reg const flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
    ++p_ccb->s_isr_all_cnt;
  } else if (p_ccb->s_isr_all_cnt < ((OsEE_byte)-1)) {
    ++p_ccb->s_isr_all_cnt;
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SuspendAllInterrupts);

  return;
}

void
  ResumeAllInterrupts
(
  void
)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  if (p_ccb->s_isr_all_cnt > 0U) {
    if (--p_ccb->s_isr_all_cnt == 0U) {
      osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
    }
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ResumeAllInterrupts);

  return;
}

void
  SuspendOSInterrupts
(
  void
)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  if (p_ccb->s_isr_os_cnt == 0U) {
    OsEE_reg const flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
    ++p_ccb->s_isr_os_cnt;
  } else if (p_ccb->s_isr_os_cnt < ((OsEE_byte)-1)) {
    ++p_ccb->s_isr_os_cnt;
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SuspendOSInterrupts);

  return;
}

void
  ResumeOSInterrupts
(
  void
)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  if (p_ccb->s_isr_os_cnt > 0U) {
    if (--p_ccb->s_isr_os_cnt == 0U) {
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
    }
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ResumeOSInterrupts);

  return;
}

StatusType
  StartOS
(
  AppModeType Mode
)
{
  StatusType ev;
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;
  OsEE_reg const flags = osEE_begin_primitive();

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);

  osEE_lock_kernel();

  if (p_ccb->os_status == OSEE_KERNEL_STOPPED) {
    if (osEE_cpu_startos()) {

      OsEE_TDB * const
        p_idle_tdb = p_cdb->p_idle_task;
# 235 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
      p_ccb->os_status = OSEE_KERNEL_STARTING;
      p_ccb->app_mode = Mode;

      osEE_call_startup_hook(p_ccb);


      {
        MemSize i;
        OsEE_autostart_trigger * const
          p_auto_triggers = &(*p_cdb->p_autostart_trigger_array)[Mode];

        osEE_lock_core(p_cdb);

        for (i = 0U; i < p_auto_triggers->trigger_array_size; ++i) {
          OsEE_autostart_trigger_info * const
            p_trigger_to_act_info = &(*p_auto_triggers->p_trigger_ptr_array)[i];
          OsEE_TriggerDB * const
            p_trigger_to_act_db = p_trigger_to_act_info->p_trigger_db;


          (void)osEE_alarm_set_rel(
            p_trigger_to_act_db->p_counter_db,
            p_trigger_to_act_db,
            p_trigger_to_act_info->increment,
            p_trigger_to_act_info->cycle
          );
        }

        osEE_unlock_core(p_cdb);
      }



      {
        MemSize i;
        OsEE_autostart_tdb * const
          p_auto_tdb = &(*p_cdb->p_autostart_tdb_array)[Mode];

        OsEE_RQ * const
          p_rq = &p_ccb->rq;
        OsEE_SN * * const
          pp_free_sn = &p_ccb->p_free_sn;

        osEE_lock_core(p_cdb);
# 288 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
        for (i = 0U; i < p_auto_tdb->tdb_array_size; ++i) {
          OsEE_TDB * const
            p_tdb_to_act = (*p_auto_tdb->p_tdb_ptr_array)[i];
          OsEE_TCB * const
            p_tcb_to_act = p_tdb_to_act->p_tcb;


          ++p_tcb_to_act->current_num_of_act;
          p_tcb_to_act->status = OSEE_TASK_READY;

          (void)osEE_scheduler_rq_insert(
            p_rq,
            osEE_sn_alloc(pp_free_sn),
            p_tdb_to_act
          );
        }


        osEE_unlock_core(p_cdb);

      }


      if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
        p_ccb->os_status = OSEE_KERNEL_STARTED;
      }

      osEE_unlock_kernel();

      osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);


      if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
        osEE_idle_task_start(p_idle_tdb);
      }
# 343 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
      ev = E_OK;

      if (p_ccb->os_status == OSEE_KERNEL_STARTED) {



        osEE_hal_set_ipl(0U);

        osEE_hal_enableIRQ();
      }
    } else {
      osEE_unlock_kernel();
      ev = E_OS_SYS_INIT;
    }
  } else {
    osEE_unlock_kernel();
    ev = E_OS_ACCESS;
  }

  if (ev != E_OK) {
    osEE_set_service_id(p_ccb, OSServiceId_StartOS);
    osEE_call_error_hook(p_ccb, ev);
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}

AppModeType
  GetActiveApplicationMode
(
  void
)
{
  AppModeType app_mode;
  OsEE_CCB * const
    p_ccb = osEE_get_curr_core()->p_ccb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = ((AppModeType)-1);
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}

StatusType
  ActivateTask
(
  TaskType TaskID
)
{
  StatusType ev;
  OsEE_KDB * const p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_TDB * const
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
    OsEE_CDB * const
      p_cdb = osEE_get_task_curr_core(p_tdb_act);

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      OsEE_reg const flags = osEE_begin_primitive();

      ev = osEE_scheduler_task_activated(p_kdb, p_cdb, p_tdb_act, OSEE_TRUE);

      osEE_end_primitive(flags);
    } else {
      ev = E_OS_ID;
    }
  }
# 450 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}


StatusType
  ChainTask
(
  TaskType TaskID
)
{
  StatusType ev;
  OsEE_KDB * const p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else {
    OsEE_TDB * const
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
    OsEE_CDB * const
      p_cdb = osEE_get_task_curr_core(p_tdb_act);
    OsEE_TDB * const
      p_curr = osEE_get_curr_task();

    OsEE_TCB * const
      p_curr_tcb = p_curr->p_tcb;


    if (p_curr->task_type >= OSEE_TASK_TYPE_ISR2) {
      ev = E_OS_CALLEVEL;
    } else

    if (p_curr_tcb->p_first_mtx != 
# 486 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                                  ((void *)0)
# 486 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                                      ) {





    {
      ev = E_OS_RESOURCE;
    }
  } else


    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      OsEE_reg const flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {

        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
        ev = E_OK;
      } else {
        ev = osEE_scheduler_task_activated(p_kdb, p_cdb, p_tdb_act, OSEE_FALSE);
      }
      if (ev == E_OK) {

        osEE_hal_terminate_activation(&osEE_get_curr_task()->hdb,
          &osEE_scheduler_task_end);
      }
      osEE_end_primitive(flags);
    } else {
      ev = E_OS_ID;
    }
  }
# 540 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  TerminateTask
(
  void
)
{
  StatusType ev;
  OsEE_CDB * const
    p_cdb = osEE_get_curr_core();
  OsEE_CCB * const
    p_ccb = p_cdb->p_ccb;
  OsEE_TDB * const
    p_curr = p_ccb->p_curr;


  OsEE_TCB * const
    p_curr_tcb = p_curr->p_tcb;


  osEE_orti_trace_service_entry(p_ccb, OSServiceId_TerminateTask);
# 573 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)

  )




  {
    ev = E_OS_CALLEVEL;
  } else

  if (p_curr_tcb->p_first_mtx != 
# 584 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                                ((void *)0)
# 584 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                                    ) {





    {
      ev = E_OS_RESOURCE;
    }
  } else




  {
    OsEE_reg const
      flags = osEE_begin_primitive();


    osEE_hal_terminate_activation(
      &p_curr->hdb, &osEE_scheduler_task_end
    );

    osEE_end_primitive(flags);

    ev = E_OK;
  }
# 622 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_TerminateTask);

  return ev;
}

StatusType
  Schedule
(
  void
)
{
  StatusType ev;
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;
  OsEE_TDB * const p_curr = p_ccb->p_curr;
  OsEE_TCB * const p_tcb = p_curr->p_tcb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_Schedule);


  if (p_curr->task_type > OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_CALLEVEL;
  } else

  if (p_tcb->p_first_mtx != 
# 646 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                           ((void *)0)
# 646 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                               ) {
    ev = E_OS_RESOURCE;
  } else


  if (p_tcb->current_prio == p_curr->dispatch_prio)
  {

    OsEE_reg const flags = osEE_begin_primitive();


    p_tcb->current_prio = p_curr->ready_prio;

    osEE_scheduler_task_preemption_point(osEE_get_kernel(), p_cdb);

    p_tcb->current_prio = p_curr->dispatch_prio;


    osEE_end_primitive(flags);

    ev = E_OK;
  } else {

    ev = E_OK;
  }
# 682 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}


StatusType
  GetResource
(
  ResourceType ResID
)
{
  StatusType ev;
  OsEE_KDB * const p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_MDB * const
      p_mtx = (*p_kdb->p_res_ptr_array)[ResID];
    OsEE_MCB * const
      p_mtx_mcb = p_mtx->p_mcb;
    OsEE_TDB * const
      p_tdb = osEE_get_curr_task();
    OsEE_TCB * const
      p_tcb = p_tdb->p_tcb;
    TaskPrio const
      mtx_prio = p_mtx->mtx_prio;


    if ((p_mtx_mcb->locked) || (p_tdb->ready_prio > mtx_prio)) {
      ev = E_OS_ACCESS;
    } else

    {
      TaskPrio const
        current_prio = p_tcb->current_prio;

      if (current_prio < mtx_prio) {

        osEE_hal_set_ipl(mtx_prio);
        p_tcb->current_prio = mtx_prio;
      }

      p_mtx_mcb->p_next = p_tcb->p_first_mtx;
      p_mtx_mcb->prev_prio = current_prio;

      p_mtx_mcb->locked = OSEE_TRUE;




      p_tcb->p_first_mtx = p_mtx;

      ev = E_OK;
    }
  }
# 767 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  ReleaseResource
(
  ResourceType ResID
)
{
  StatusType ev;
  OsEE_KDB * const p_kdb = osEE_get_kernel();
  OsEE_CDB * const p_cdb = osEE_get_curr_core();





  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_TDB * const
      p_tdb = osEE_get_curr_task();
    OsEE_TCB * const
      p_tcb = p_tdb->p_tcb;
    OsEE_MDB * const
      p_mtx = (*p_kdb->p_res_ptr_array)[ResID];
    OsEE_MCB * const
      p_mtx_mcb = p_mtx->p_mcb;


    if ((p_mtx_mcb->locked == OSEE_FALSE) || (p_tcb->p_first_mtx != p_mtx)) {
      ev = E_OS_NOFUNC;
    } else

    {
      OsEE_reg
        flags = osEE_begin_primitive();

      p_tcb->p_first_mtx = p_tcb->p_first_mtx->p_mcb->p_next;


      if (p_tcb->p_first_mtx != 
# 809 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                               ((void *)0)
# 809 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                                   ) {
        TaskPrio const
          prev_prio = p_mtx_mcb->prev_prio;

        p_tcb->current_prio = prev_prio;
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        TaskPrio const
          dispatch_prio = p_tdb->dispatch_prio;

        p_tcb->current_prio = dispatch_prio;
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_mtx_mcb->locked = OSEE_FALSE;






      (void)osEE_scheduler_task_preemption_point(p_kdb, p_cdb);

      osEE_end_primitive(flags);

      ev = E_OK;
    }
  }
# 858 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}


StatusType
  ShutdownOS
(
  StatusType Error
)
{
  StatusType ev;
  OsEE_CDB * const p_cdb = osEE_get_curr_core();
  OsEE_CCB * const p_ccb = p_cdb->p_ccb;
  OsEE_reg const flags = osEE_begin_primitive();
  OsEE_kernel_status const os_status = p_ccb->os_status;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ShutdownOS);

  if ((os_status == OSEE_KERNEL_STARTED) || (os_status == OSEE_KERNEL_STARTING))
  {
    p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;

    p_ccb->last_error = Error;


    osEE_hal_disableIRQ();
    osEE_call_shutdown_hook(p_ccb, Error);
    while (1) {
      ;
    }






  } else {
    ev = E_OS_STATE;
  }

  if (ev != E_OK) {
    osEE_call_error_hook(p_ccb, ev);
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}

StatusType
  GetTaskID
(
  TaskRefType TaskID
)
{
  StatusType ev;
# 926 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if (TaskID == 
# 926 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
               ((void *)0)
# 926 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                   ) {
    ev = E_OS_PARAM_POINTER;
  } else {
    TaskType
      tid = ((TaskType)-1);
    OsEE_TDB const * const
      p_tdb = osEE_get_curr_task();

    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
      OsEE_CCB * const
        p_ccb = osEE_get_curr_core()->p_ccb;

      OsEE_SN *
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != 
# 943 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                    ((void *)0)
# 943 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                        ) {
        OsEE_TDB const * const
          p_searched_tdb = p_sn->p_tdb;
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
          tid = p_searched_tdb->tid;
          break;
        } else {
          p_sn = p_sn->p_next;
        }
      }
    }

    (*TaskID) = tid;
    ev = E_OK;
  }
# 980 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  GetTaskState
(
  TaskType TaskID,
  TaskStateRefType State
)
{
  StatusType ev;
  OsEE_KDB * const p_kdb = osEE_get_kernel();
# 1003 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if (State == 
# 1003 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
              ((void *)0)
# 1003 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                  ) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_TDB * const
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];


    TaskType const local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = OSEE_TASK_SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = OSEE_TASK_READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = OSEE_TASK_WAITING;
        break;
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = OSEE_TASK_RUNNING;
        break;
      default:
        ;
        break;
    }
    ev = E_OK;
  }
# 1060 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}


StatusType
  SetRelAlarm
(
  AlarmType AlarmID,
  TickType increment,
  TickType cycle
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_AlarmDB * const
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
    OsEE_CounterDB * const
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;



    if ((increment == 0U) ||
        (increment > p_counter_db->info.maxallowedvalue) ||
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
    } else

    {
      OsEE_reg const
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_rel(p_counter_db, p_alarm_db, increment, cycle);

      osEE_end_primitive(flags);
    }
  }
# 1136 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  SetAbsAlarm
(
  AlarmType AlarmID,
  TickType start,
  TickType cycle
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_AlarmDB * const
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
    OsEE_CounterDB * const
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;



    if ((start > p_counter_db->info.maxallowedvalue) ||
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
    } else

    {
      OsEE_reg const
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_abs(p_counter_db, p_alarm_db, start, cycle);

      osEE_end_primitive(flags);
    }
  }
# 1210 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  CancelAlarm
(
  AlarmType AlarmID
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else {
    OsEE_AlarmDB * const
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
    OsEE_reg const
      flags = osEE_begin_primitive();

    ev = osEE_alarm_cancel(p_alarm_db);

    osEE_end_primitive(flags);
  }
# 1262 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  GetAlarm
(
  AlarmType AlarmID,
  TickRefType Tick
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == 
# 1284 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
             ((void *)0)
# 1284 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                 ) {
    ev = E_OS_PARAM_POINTER;
  } else
  {
    OsEE_AlarmDB * const
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
    OsEE_reg const
      flags = osEE_begin_primitive();

    ev = osEE_alarm_get(p_alarm_db, Tick);

    osEE_end_primitive(flags);
  }
# 1321 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  GetAlarmBase
(
  AlarmType AlarmID,
  AlarmBaseRefType Info
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();






  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == 
# 1343 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
             ((void *)0)
# 1343 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                 ) {
    ev = E_OS_PARAM_POINTER;
  } else
  {
    OsEE_AlarmDB * const
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
    OsEE_TriggerDB * const
      p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
    OsEE_CounterDB * const
      p_counter_db = p_trigger_db->p_counter_db;

    *Info = p_counter_db->info;

    ev = E_OK;
  }
# 1382 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}




StatusType
  WaitEvent
(
  EventMaskType Mask
)
{
  StatusType ev;
  OsEE_CDB * const
    p_cdb = osEE_get_curr_core();
  OsEE_CCB * const
    p_ccb = p_cdb->p_ccb;
  OsEE_TDB * const
    p_curr = p_ccb->p_curr;
  OsEE_TCB * const
    p_curr_tcb = p_curr->p_tcb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_WaitEvent);
# 1416 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)

  )




  {
    ev = E_OS_CALLEVEL;
  } else

  if (p_curr_tcb->p_first_mtx != 
# 1430 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                                ((void *)0)
# 1430 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                                    ) {





    {
      ev = E_OS_RESOURCE;
    }
  } else
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_ACCESS;
  } else



  if ((p_curr_tcb->event_mask & Mask) == 0U) {
    OsEE_SN * p_blocked_sn;
    OsEE_TDB * p_to;

    OsEE_reg const flags = osEE_begin_primitive();


    p_curr_tcb->wait_mask = Mask;


    osEE_lock_core(p_cdb);

    p_to = osEE_scheduler_task_block_current(osEE_get_kernel(),
              p_cdb, &p_blocked_sn);



    osEE_sn_release(&p_ccb->p_free_sn, p_blocked_sn);

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_to);


    p_curr_tcb->wait_mask = 0U;

    osEE_end_primitive(flags);

    ev = E_OK;
  } else {
    ev = E_OK;
  }
# 1493 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}

StatusType
  SetEvent
(
  TaskType TaskID,
  EventMaskType Mask
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();


  OsEE_CDB * const
    p_curr_cdb = osEE_get_curr_core();
  OsEE_CCB * const
    p_curr_ccb = p_curr_cdb->p_ccb;

  OsEE_TDB * const
    p_curr = p_curr_ccb->p_curr;

  osEE_orti_trace_service_entry(p_curr_ccb, OSServiceId_SetEvent);
# 1530 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if (osEE_check_disableint(p_curr_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)

  )




  {
    ev = E_OS_CALLEVEL;
  } else




  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else {
    OsEE_TDB * const
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
    OsEE_TCB * const
      p_tcb_waking_up = p_tdb_waking_up->p_tcb;
    OsEE_CDB * const
      p_cdb_waking_up = osEE_get_task_curr_core(p_tdb_waking_up);
    OsEE_reg const
      flags = osEE_begin_primitive();


    osEE_lock_core(p_cdb_waking_up);


    if (p_tdb_waking_up->task_type != OSEE_TASK_TYPE_EXTENDED) {
      osEE_unlock_core(p_cdb_waking_up);
      osEE_end_primitive(flags);
      ev = E_OS_ACCESS;
    } else
    if (p_tcb_waking_up->status == OSEE_TASK_SUSPENDED) {
      osEE_unlock_core(p_cdb_waking_up);
      osEE_end_primitive(flags);
      ev = E_OS_STATE;
    } else

    {

      p_tcb_waking_up->event_mask |= Mask;

      if (((p_tcb_waking_up->wait_mask & Mask) != 0U) &&
          (p_tcb_waking_up->status == OSEE_TASK_WAITING))
      {
        OsEE_SN * const
          p_sn = osEE_sn_alloc(&p_cdb_waking_up->p_ccb->p_free_sn);

        p_sn->p_tdb = p_tdb_waking_up;


        if (osEE_scheduler_task_unblocked(p_kdb, p_cdb_waking_up, p_sn))
        {
          (void)osEE_scheduler_task_preemption_point(p_kdb, p_cdb_waking_up);
        }
      }

      osEE_unlock_core(p_cdb_waking_up);
      osEE_end_primitive(flags);

      ev = E_OK;
    }
  }
# 1619 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  GetEvent
(
  TaskType TaskID,
  EventMaskRefType Event
)
{
  StatusType ev;
  OsEE_KDB * const
    p_kdb = osEE_get_kernel();


  OsEE_CDB * const
    p_cdb = osEE_get_curr_core();
  OsEE_CCB * const
    p_ccb = p_cdb->p_ccb;





  OsEE_TDB * const
    p_curr = p_ccb->p_curr;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetEvent);
# 1657 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)

  )






  {
    ev = E_OS_CALLEVEL;
  } else




  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    OsEE_TDB * const
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
    OsEE_TCB * const
      p_tcb_event = p_tdb_event->p_tcb;



    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
      ev = E_OS_ACCESS;
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else

    if (Event == 
# 1694 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c" 3 4
                ((void *)0)
# 1694 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
                    ) {
      ev = E_OS_PARAM_POINTER;
    } else
    {
      (*Event) = p_tcb_event->event_mask;

      ev = E_OK;
    }
  }
# 1723 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  return ev;
}

StatusType
  ClearEvent
(
  EventMaskType Mask
)
{
  StatusType ev;
  OsEE_CDB * const
    p_cdb = osEE_get_curr_core();
  OsEE_CCB * const
    p_ccb = p_cdb->p_ccb;
  OsEE_TDB * const
    p_curr = p_ccb->p_curr;
  OsEE_TCB * const
    p_curr_tcb = p_curr->p_tcb;

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ClearEvent);
# 1754 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)

  )




  {
    ev = E_OS_CALLEVEL;
  } else
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_ACCESS;
  } else

  {

    p_curr_tcb->event_mask &= ~Mask;

    ev = E_OK;
  }
# 1791 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
# 1839 "/home/user/lab-osek/OSEK-GroupProject/erika/src/ee_oo_api_osek.c"
ISRType
  GetISRID
(
  void
)
{
  ISRType isr_id;
  OsEE_TDB const * const
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
    isr_id = p_tdb->tid;
  } else {
    isr_id = ((TaskType)-1);
  }

  return isr_id;
}
